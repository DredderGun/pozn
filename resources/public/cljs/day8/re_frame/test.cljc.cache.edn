{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {}, :excludes #{}, :name day8.re-frame.test, :imports nil, :requires {re-frame.interop re-frame.interop, test cljs.test, rf re-frame.core, cljs.test cljs.test, re-frame.router re-frame.router, rf.router re-frame.router, rf.db re-frame.db, rf.int re-frame.interop, re-frame.db re-frame.db, re-frame.core re-frame.core}, :cljs.spec/speced-vars [], :uses nil, :defs {*test-timeout* {:name day8.re-frame.test/*test-timeout*, :file "resources/public/cljs/day8/re_frame/test.cljc", :line 49, :column 1, :end-line 49, :end-column 30, :dynamic true, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 49, :column 16, :end-line 49, :end-column 30, :dynamic true}, :tag number}, run-test-async* {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 61, :column 7, :end-line 61, :end-column 22, :arglists (quote ([f]))}, :name day8.re-frame.test/run-test-async*, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 22, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 61, :end-line 61, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, dequeue! {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 16, :column 8, :end-line 16, :end-column 16, :private true, :arglists (quote ([queue-atom])), :doc "Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."}, :private true, :name day8.re-frame.test/dequeue!, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 16, :method-params ([queue-atom]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 16, :end-line 16, :max-fixed-arity 1, :fn-var true, :arglists (quote ([queue-atom])), :doc "Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."}, ->t_day8$re_frame$test18408 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.test/IAsyncTest cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([f test-context meta18409])), :file nil}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.test/IAsyncTest cljs.core/IWithMeta}, :name day8.re-frame.test/->t_day8$re_frame$test18408, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :method-params ([f test-context meta18409]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 14, :factory :positional, :line 97, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f test-context meta18409])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, run-test-sync {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 288, :column 11, :end-line 288, :end-column 24, :macro true, :arglists (quote ([& body])), :doc "Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name day8.re-frame.test/run-test-sync, :variadic true, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 288, :macro true, :end-line 288, :max-fixed-arity 2, :fn-var false, :arglists ([&form &env & body]), :doc "Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call."}, as-callback-pred {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 123, :column 8, :end-line 123, :end-column 24, :private true, :arglists (quote ([callback-pred])), :doc "Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."}, :private true, :name day8.re-frame.test/as-callback-pred, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 24, :method-params ([callback-pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 123, :end-line 123, :max-fixed-arity 1, :fn-var true, :arglists (quote ([callback-pred])), :doc "Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."}, wait-for* {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 142, :column 7, :end-line 142, :end-column 16, :arglists (quote ([ok-ids failure-ids callback])), :doc "This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."}, :name day8.re-frame.test/wait-for*, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 16, :method-params ([ok-ids failure-ids callback]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 142, :end-line 142, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ok-ids failure-ids callback])), :doc "This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."}, run-test-async {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 103, :column 11, :end-line 103, :end-column 25, :macro true, :arglists (quote ([& body])), :doc "Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name day8.re-frame.test/run-test-async, :variadic true, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 103, :macro true, :end-line 103, :max-fixed-arity 2, :fn-var false, :arglists ([&form &env & body]), :doc "Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't)."}, run-test-sync* {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 270, :column 7, :end-line 270, :end-column 21, :arglists (quote ([f]))}, :name day8.re-frame.test/run-test-sync*, :variadic false, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 270, :end-line 270, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, *test-context* {:meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 51, :column 38, :end-line 51, :end-column 52, :dynamic true, :private true}, :private true, :name day8.re-frame.test/*test-context*, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 52, :column 1, :dynamic true, :line 51, :end-line 51, :tag clj-nil, :doc "`*test-context*` is used to communicate internal details of the test between\n  `run-test-async*` and `wait-for*`. It is dynamically bound so that it doesn't\n  need to appear as a lexical argument to a `wait-for` block, since we don't\n  want it to be visible when you're writing tests.  But care must be taken to\n  pass it around lexically across callbacks, since ClojureScript doesn't have\n  `bound-fn`."}, t_day8$re_frame$test18408 {:num-fields 3, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.test/IAsyncTest cljs.core/IWithMeta}, :name day8.re-frame.test/t_day8$re_frame$test18408, :file "resources/public/cljs/day8/re_frame/test.cljc", :type true, :anonymous true, :column 14, :line 97, :record false, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, *handling* {:meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 268, :column 38, :end-line 268, :end-column 48, :dynamic true, :private true}, :private true, :name day8.re-frame.test/*handling*, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 48, :column 1, :dynamic true, :line 268, :end-line 268, :tag boolean}, wait-for {:protocol-inline nil, :meta {:file "/home/aleksandr/projects/pozn-adaptive/resources/public/cljs/day8/re_frame/test.cljc", :line 206, :column 11, :end-line 206, :end-column 19, :macro true, :arglists (quote ([[ids failure-ids event-sym :as argv] & body])), :doc "Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env [ids failure-ids event-sym :as argv] body)], :arglists ([&form &env [ids failure-ids event-sym :as argv] & body]), :arglists-meta (nil)}}, :name day8.re-frame.test/wait-for, :variadic true, :file "resources/public/cljs/day8/re_frame/test.cljc", :end-column 19, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env [ids failure-ids event-sym :as argv] body)], :arglists ([&form &env [ids failure-ids event-sym :as argv] & body]), :arglists-meta (nil)}, :method-params [(&form &env [ids failure-ids event-sym :as argv] body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 206, :macro true, :end-line 206, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env [ids failure-ids event-sym :as argv] & body]), :doc "Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure."}}, :cljs.spec/registry-ref [], :require-macros {day8.re-frame.test day8.re-frame.test, test cljs.test, cljs.test cljs.test}, :cljs.analyzer/constants {:seen #{:max-wait-for-depth test-context :done :else :now-waiting-for day8.re-frame.test/wait-for* day8.re-frame.test/run-test-async* :type meta18409 :wait-for-depth :fail fail-pred :callback-pred not day8.re-frame.test/run-test-sync* :expected cljs.core/fn :error event :pass :actual :message f}, :order [:wait-for-depth :max-wait-for-depth :now-waiting-for :done f test-context meta18409 day8.re-frame.test/run-test-async* cljs.core/fn :else :callback-pred :type :expected :actual :message :error not fail-pred event :pass :fail day8.re-frame.test/wait-for* day8.re-frame.test/run-test-sync*]}, :doc nil}