(cljs.test/run-tests 'pozn-adaptive.test.core-test)
(def a (agent 0))
a
(add-watch a :key (fn [k r os ns] (print "KEY:" k "R:" r "OS:" os "NS:" ns)))
(send a inc)
(def custom-atom (atom false))
(swap! custom-atom not)
custom-atom
(str "sandwich-menu-container " (when true "change"))
(str "sandwich-menu-container " (when @custom-atom "change"))
(def some-f (comp drop-last #(into [] %)))
(some-f [1 2 3 4 5 6])
(def some-f (comp #(into [] %) drop-last))
(some-f [1 2 3 4 5 6])
(def dishes {1 {:id 1 :sum 22} 2 {:id 2 :sum 55}})
(def dishes {1 {:id 1 :sum 22 :count 2} 2 {:id 2 :sum 55 :count 4}})
(defn reduce-map [acc dish] (+ (* (:count dish) (:price dish)) acc))
(reduce reduce-map dishes)
(reduce reduce-map 0 dishes)
(defn reduce-map-f [acc dish] (+ (* (:count dish) (:price dish)) acc))
(reduce reduce-map-f 0 dishes)
(defn reduce-map [acc dish] (+ (* (:count (second dish)) (:price (second dish))) acc))
(reduce reduce-map-f 0 dishes)
(defn reduce-map-f [acc dish] (+ (* (:count (second dish)) (:price (second dish))) acc))
(def dishes {1 {:id 1 :sum 22} 2 {:id 2 :sum 55}})
(reduce reduce-map-f 0 dishes)
(defn reduce-map-f [acc dish] (prn (second dish)) (+ (* (:count (second dish)) (:price (second dish))) acc))
(reduce reduce-map-f 0 dishes)
(def dishes {1 {:id 1 :sum 22 :count 2} 2 {:id 2 :sum 55 :count 4}})
(reduce reduce-map-f 0 dishes)
(defn reduce-map-f [acc dish] (+ (* (:count (second dish)) (:sum (second dish))) acc))
(def dishes {1 {:id 1 :sum 22 :count 2} 2 {:id 2 :sum 55 :count 4}})
(reduce reduce-map-f 0 dishes)
(map #(prn %) {1 {:id 1 :dish [1 2 3 4]} 2 {:id 2 :dish [1 2 3 4]}})
(map #(assoc (second %) :selected? true) {1 {:id 1 :dish [1 2 3 4]} 2 {:id 2 :dish [1 2 3 4]}})
(reduce-kv (fn [m k v] 
             (assoc m k (assoc v :selected? true))) 
           {}
           {1 {:id 1 :dish [1 2 3 4]} 2 {:id 2 :dish [1 2 3 4]}})
(subs "Lorem Ipsum" 0 200)
(subs "Lorem Ipsum" 0 6)
(defn trunc
  [s n]
  (subs s 0 (min (count s) n)))
(trunc "Lorem Ipsum" 0 200)
(trunc "Lorem Ipsum" 200)
<<<<<<< HEAD
(if [] true false)
(if (empty? []) true false)
(if (empty? [2 3]) true false)
(for [s {1 {:id 1 :message "dsdsf" :id 2 :message "dsf"}] s)
(for [s {1 {:id 1 :message "dsdsf" 2 {:id 2 :message "dsf"}}] s)
(for [s {1 {:id 1 :message "dsdsf" 2 {:id 2 :message "dsf"}}}] s)
(for [s {1 {:id 1 :message "dsdsf"} 2 {:id 2 :message "dsf"}}] s)
(for [s {1 {:id 1 :message "dsdsf"} 2 {:id 2 :message "dsf"}}] (second s))
=======
(seq [2 2 3])
(when '() true)
>>>>>>> receipt-fix
(count "qwerty")
(count "q")
(remove-last "qqq2")
remove-last (fn [s]
                      (subs s
                            0
                            (- (count s) 1)))
(remove-last "qqqqqq2")
(def remove-last (fn [s]
                      (subs s
                            0
                            (- (count s) 1))))
(remove-last "qqqqqq2")
(count "")
(def comp-fun (comp inc inc dec))
(def comp-fun (comp inc dec prn))
(comp-fun 9)
(defn pr [n] (do (prn n) n))
(def comp-fun (comp inc dec pr))
(comp-fun 9)
(def comp-fun (comp dec pr))
(comp-fun 9)
(remove-last "qwerty")
(if 0 true false)
(if nil true false)
